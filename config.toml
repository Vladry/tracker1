# ============================================================================
# Application configuration file
# Format: TOML (Tom's Obvious, Minimal Language)
#
# bbox  = Bounding Box (ограничивающий прямоугольник)
# HUD   = Heads-Up Display (экранные наложения)
# IoU   = Intersection over Union (метрика перекрытия)
# ============================================================================



[rtsp]
# URL RTSP-потока.
# Пример: "rtsp://192.168.144.25:8554/main.264"
# Важно: это тот самый параметр, который раньше часто "утекал" в виде константы RTSP_URL в коде.
url = "rtsp://192.168.144.25:8554/main.264"

# Протоколы rtspsrc:
# 1 = UDP (минимальная задержка, но возможны потери пакетов)
# 4 = TCP (более надёжно, но обычно больше задержка)
protocols = 1

# latency (мс) для rtspsrc.
# 0 = минимальная задержка.
latency_ms = 0

# Таймауты rtspsrc (микросекунды).
# Обычно достаточно 2'000'000 (2 секунды).
timeout_us = 2000000
tcp_timeout_us = 2000000

# Принудительная capset-строка перед appsink.
# Нужна, чтобы гарантировать формат кадра для OpenCV (NV12).
caps_force = "video/x-raw,format=NV12"

# Включить подробные логи нашего RTSP-воркера (std::cout / std::cerr).
verbose = true

[rtsp.watchdog]
# -------------------------
# Watchdog RTSP (авторестарт)
# -------------------------
# Если кадры перестали приходить на протяжении указанного времени,
# watchdog инициирует rtsp.restart() в control-потоке.

# Таймаут отсутствия кадров (мс). После этого считаем, что поток "завис".
no_frame_timeout_ms = 1500

# Минимальная пауза между рестартами (мс), защита от "дребезга".
restart_cooldown_ms = 1000

# Стартовая "льгота" (мс) после запуска приложения:
# пока пайплайн/камера инициализируются, не считаем отсутствие кадров ошибкой.
startup_grace_ms = 3000


[detector]
# Минимальная разница яркости между кадрами,
# при которой пиксель считается движущимся.
diff_threshold = 15

# Минимальная площадь bbox, чтобы он считался валидной детекцией.
min_area = 50

# Размер морфологического ядра для очистки бинарной маски.
morph_kernel = 5

# Коэффициент масштабирования кадра перед детекцией.
downscale = 1.0


[merge]
# Максимальное количество dynamic bbox,
# объединяемых в одну merged-цель.
max_boxes_in_cluster = 3

# Минимальный IoU (Intersection over Union),
# при котором два bbox считаются соседними.
neighbor_iou_th = 0.05

# Коэффициент расстояния между центрами bbox,
# используемый как эвристика объединения.
center_dist_factor = 5.5

# Максимальная кратность площади merged-bbox
# относительно площади САМОГО КРУПНОГО bbox в кластере.
max_area_multiplier = 3.0


[tracker]
# Максимально допустимое количество пропущенных кадров
# до потери цели.
max_missed_frames = 3


# Максимальное количество динамических целей (ограничение трекера).
# Защита от \"взрыва\" количества треков на шумных сценах.
max_targets = 50
# Минимальный IoU для сопоставления bbox между кадрами.
iou_th = 0.25


[static_rebind]
# Автоматическая перепривязка static bbox при потере цели.
auto_rebind = true

# Таймаут (в миллисекундах) ожидания новой цели
# после потери родительского dynamic bbox.
rebind_timeout_ms = 800

# Приоритет расстояния (distance priority).
distance_weight = 1.0

# Приоритет размера цели (area priority).
area_weight = 1.0

# Во сколько раз новая цель должна быть крупнее предыдущей,
# чтобы считаться значимо более крупной.
larger_area_factor = 2.0

# Максимально допустимое расстояние до более крупной цели,
# выраженное как доля диагонали кадра.
# 0.2 = 1/5 диагонали.
max_large_target_dist_frac = 0.2



# Порог IoU для подтверждения, что static bbox всё ещё привязан к своей родительской dynamic цели.
parent_iou_th = 0.15

# Порог уверенности (скор) для повторной привязки (reattach).
# Нужен, чтобы не дёргаться на сомнительных совпадениях.
reattach_score_th = 0.20
[overlay]
# Прозрачность HUD (Heads-Up Display).
hud_alpha = 0.25

# Прозрачность невыбранных bbox,
# когда есть активный static bbox.
unselected_alpha_when_selected = 0.3


[smoothing]
# Количество кадров для сглаживания dynamic bbox
# (moving average).
dynamic_bbox_window = 5
