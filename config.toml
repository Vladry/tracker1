[detector]
# Использовать RKNN-детектор.
# true = включить RKNN, false = отключить детектор.
use_rknn = true

# Путь к модели RKNN.
rknn_model_path = "models/yolov8n_fp16.rknn"

# Нормализация входа.
rknn_scale = 0.0039215686
rknn_swap_rb = true

# Пороги уверенности и NMS для RKNN.
rknn_conf_threshold = 0.35
rknn_nms_threshold = 0.45

# Фильтр по классу (-1 = все классы).
rknn_class_id = -1



[tracker]
# Максимально допустимое количество пропущенных кадров
# до потери цели.
# Больше = дольше держим трек без подтверждения,
# но больше риск "призрачных" треков.
# Меньше = быстрее сбрасываем, но цель может потеряться раньше.
max_missed_frames = 10


# Максимальное количество динамических целей (ограничение трекера).
# Больше = больше целей отслеживаем, но выше нагрузка и шум.
# Меньше = меньше шумных треков, но можем терять объекты.
# Защита от "взрыва" количества треков на шумных сценах.
max_targets = 50
# Минимальный IoU для сопоставления bbox между кадрами.
# Больше = строже соответствие, меньше ошибок склейки,
# но больше разрывов треков.
# Меньше = легче сопоставлять, но риск неверной склейки.
iou_th = 0.15 #бОльшее значение рисует для каждой цели шлейф из боксов

# Оставлять только ведущую цель по направлению движения
# (полезно против "шлейфа" боксов за движущимся объектом).
leading_only = true

# Минимальная скорость (пикселей/кадр), при которой направление учитывается
leading_min_speed = 2.0


[static_rebind]
# Автоматическая перепривязка static bbox при потере цели.
# true = авто-поиск новой цели, false = остаёмся в отцепленном состоянии.
auto_rebind = true

# Таймаут (в миллисекундах) ожидания новой цели
# после потери родительского dynamic bbox.
# Больше = дольше ждём похожую цель, но больше "зависание".
# Меньше = быстрее отбрасываем, но можем не успеть перепривязать.
rebind_timeout_ms = 200

# Приоритет расстояния (distance priority).
# Больше = выбираем ближайшие цели, но игнорируем размер.
# Меньше = расстояние менее важно, больше веса у других факторов.
distance_weight = 6.0

# Приоритет размера цели (area priority).
# Больше = предпочтение более крупным целям,
# но можно перепривязаться к "чужому" большому объекту.
# Меньше = размер менее важен, больше роль расстояния.
area_weight = 1.0

# Во сколько раз новая цель должна быть крупнее предыдущей,
# чтобы считаться значимо более крупной.
# Больше = реже признаём "крупнее", меньше смен.
# Меньше = легче перескакиваем на большую цель.
larger_area_factor = 1.5

# Максимально допустимое расстояние до более крупной цели,
# выраженное как доля диагонали кадра.
# Больше = допускаем более далёкие цели,
# Меньше = строгая привязка к близким объектам.
# 0.2 = 1/5 диагонали.
max_large_target_dist_frac = 0.1



# Порог IoU для подтверждения, что static bbox всё ещё привязан к своей родительской dynamic цели.
# Больше = строже подтверждение, но выше риск ложного "отцепления".
# Меньше = легче подтверждать, но больше шанс ошибочного соответствия.
parent_iou_th = 0.85

# Порог уверенности (скор) для повторной привязки (reattach).
# Больше = меньше ложных перепривязок, но можем пропустить правильную.
# Меньше = легче перепривязаться, но выше риск неправильной цели.
reattach_score_th = 0.20
[overlay]
# Прозрачность HUD (Heads-Up Display).
# Больше = HUD заметнее, но может закрывать изображение.
# Меньше = менее навязчиво, но хуже читаемость.
hud_alpha = 0.25

# Прозрачность невыбранных bbox,
# когда есть активный static bbox.
# Больше = боксы заметнее, но больше визуального шума.
# Меньше = чище картинка, но меньше контекста.
unselected_alpha_when_selected = 0.3


[smoothing]
# Количество кадров для сглаживания dynamic bbox
# (moving average).
# Больше = плавнее, но выше задержка и "инерция".
# Меньше = более отзывчиво, но больше дрожание.
dynamic_bbox_window = 15


[merge]
# Максимальное количество dynamic bbox,
# объединяемых в одну merged-цель.
# Больше = агрессивнее слияние, меньше целей,
# но выше риск объединить разные объекты.
max_boxes_in_cluster = 1

# Минимальный IoU (Intersection over Union),
# при котором два bbox считаются соседними.
# Больше = нужно сильнее перекрытие, меньше слияний.
# Меньше = больше слияний, но риск склеить удалённые цели.
neighbor_iou_th = 0.5

# Коэффициент расстояния между центрами bbox,
# используемый как эвристика объединения.
# Больше = допускаем большее расстояние, больше слияний.
# Меньше = строже, меньше слияний.
center_dist_factor = 2.5

# Максимальная кратность площади merged-bbox
# относительно площади САМОГО КРУПНОГО bbox в кластере.
# Больше = допускаем крупные слияния, но bbox может раздуваться.
# Меньше = строже ограничиваем рост.
max_area_multiplier = 1.0

# ============================================================================
# Application configuration file
# Format: TOML (Tom's Obvious, Minimal Language)
#
# bbox  = Bounding Box (ограничивающий прямоугольник)
# HUD   = Heads-Up Display (экранные наложения)
# IoU   = Intersection over Union (метрика перекрытия)
# ============================================================================



[rtsp]
# URL RTSP-потока.
# Увеличение длины/сложности URL не влияет на логику, но усложняет отладку.
# Ошибка в схеме/хосте = отсутствие видео.
# Чем стабильнее адрес, тем меньше неожиданных разрывов.
url = "rtsp://192.168.144.25:8554/main.264"

# Протоколы rtspsrc:
# 1 = UDP (минимальная задержка, но возможны потери пакетов)
# 4 = TCP (надёжнее, но обычно выше задержка и нагрузка).
# Увеличение значения до TCP повышает стабильность, снижает "живость".
protocols = 1

# latency (мс) для rtspsrc.
# Больше = устойчивее поток при джиттере, но больше задержка.
# Меньше = меньше задержка, но выше риск рывков.
# 0 = минимальная задержка.
latency_ms = 0

# Таймауты rtspsrc (микросекунды).
# Больше = дольше ждём сеть (меньше ложных рестартов),
# но позже замечаем реальную проблему.
# Меньше = быстрее реакця, но больше риск флаппинга.
timeout_us = 2000000
tcp_timeout_us = 2000000

# Включить подробные логи нашего RTSP-воркера (std::cout / std::cerr).
# true = больше диагностической информации,
# но выше шум в логах и небольшие затраы.
verbose = false

[rtsp.watchdog]
# -------------------------
# Watchdog RTSP (авторестарт)
# -------------------------
# Если кадры перестали приходить на протяжении указанного времени,
# watchdog инициирует rtsp.restart() в control-потоке.

# Таймаут отсутствия кадров (мс). После этого считаем, что поток "завис".
# Больше = терпимее к паузам, но дольше простаиваем на зависшем потоке.
# Меньше = быстрее рестарт, но выше риск ложных срабатываний.
no_frame_timeout_ms = 1500

# Минимальная пауза между рестартами (мс), защита от "дребезга".
# Больше = меньше перезапусков, но медленнее восстановление.
# Меньше = быстрее подхват, но возможен цикл рестартов.
restart_cooldown_ms = 1000

# Стартовая "льгота" (мс) после запуска приложения.
# Больше = меньше ложных тревог при старте, но позднее первый рестарт.
# Меньше = быстрее реагируем, но может мешать инициализации камеры.
startup_grace_ms = 3000
