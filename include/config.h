#pragma once

#include <string>
#include <cstdint>

// ============================================================================
// Конфигурация приложения (AppConfig)
//
// Принцип проекта:
//  1) Все НАСТРОЕЧНЫЕ параметры (тюнинг поведения) находятся в config.toml.
//  2) В коде не должно быть "утёкших" магических констант, влияющих на поведение.
//  3) Если параметр отсутствует в TOML, используется безопасный дефолт из AppConfig.
//  4) Комментарии максимально подробные и по-русски (по требованию проекта).
//
// Важно: дефолты ниже должны позволять запуск даже без config.toml.
// ============================================================================

struct AppConfig {

    // -------------------------- RTSP / GStreamer --------------------------
    struct Rtsp {
        // URL видеопотока (пример: "rtsp://192.168.1.10:8554/main.264").
        // Это ключевой параметр: именно отсюда берётся адрес камеры/стрима.
        std::string url = "rtsp://192.168.144.25:8554/main.264";

        // Протоколы rtspsrc:
        // 1 = UDP (минимальная задержка, но возможны потери),
        // 4 = TCP (более надёжно, но обычно больше задержка).
        int protocols = 1;

        // latency в миллисекундах для rtspsrc.
        // 0 = минимальная задержка, но выше риск нестабильности на плохой сети.
        int latency_ms = 0;

        // Таймауты rtspsrc в микросекундах.
        // Типичный рабочий диапазон 1–5 секунд (1e6..5e6).
        std::uint64_t timeout_us = 2'000'000;
        std::uint64_t tcp_timeout_us = 2'000'000;

        // Принудительная капса на выход декодера (перед appsink).
        // Нужна, чтобы гарантировать формат кадра, который ожидает OpenCV (NV12).
        std::string caps_force = "video/x-raw,format=NV12";

        // Более подробные логи (не GST_DEBUG, а именно наши std::cout / std::cerr).
        bool verbose = true;
    } rtsp;

    // --------------------------- RTSP Watchdog ---------------------------
    struct RtspWatchdog {
        // Через сколько миллисекунд без новых кадров считаем, что RTSP "завис"
        // или камера/сеть перестала отдавать поток.
        //
        // Подбирается под вашу практику:
        //  - слишком маленькое значение даст ложные срабатывания при редких кадрах;
        //  - слишком большое значение будет долго "терпеть" зависание.
        std::uint64_t no_frame_timeout_ms = 1500;

        // Минимальная пауза между рестартами (защита от "дребезга").
        // Если камера реально недоступна, это предотвращает бесконечный цикл рестартов.
        std::uint64_t restart_cooldown_ms = 1000;

        // Стартовая "льгота" после запуска приложения (до первого кадра),
        // чтобы watchdog не дёргал RTSP во время инициализации пайплайна/камеры.
        std::uint64_t startup_grace_ms = 3000;
    } rtsp_watchdog;


    // ------------------------------ Detector ------------------------------
    struct Detector {
        // Минимальная разница яркости между кадрами,
        // при которой пиксель считается движущимся.
        int diff_threshold = 20;

        // Минимальная площадь bbox (в пикселях), чтобы он считался валидной детекцией.
        int min_area = 10;

        // Размер морфологического ядра для очистки бинарной маски (обычно 3..7).
        int morph_kernel = 3;

        // Масштабирование перед детекцией:
        // 1.0 = без downscale, < 1.0 = быстрее, но грубее и больше ошибок.
        double downscale = 1.0;
    } detector;

    // --------------------------- Merge detections --------------------------
    struct Merge {
        // Максимальное количество dynamic bbox, объединяемых в одну merged-цель.
        int max_boxes_in_cluster = 2;

        // Минимальный IoU (Intersection over Union), при котором два bbox считаются соседними.
        float neighbor_iou_th = 0.05f;

        // Коэффициент расстояния между центрами bbox (эвристика "соседства").
        // d <= center_dist_factor * ref_size.
        float center_dist_factor = 5.5f;

        // Максимальная кратность площади merged-bbox относительно площади
        // САМОГО КРУПНОГО bbox в кластере.
        // Нужно, чтобы merged-цель не разрасталась "в бесконечность".
        float max_area_multiplier = 3.0f;
    } merge;

    // ------------------------------ Tracker -------------------------------
    struct Tracker {
        // Минимальный IoU для сопоставления bbox между кадрами.
        float iou_th = 0.25f;

        // Сколько кадров подряд цель может отсутствовать (missed),
        // прежде чем трек будет удалён.
        int max_missed_frames = 3;

        // Ограничение на количество активных динамических целей (защита от "взрыва").
        int max_targets = 50;
    } tracker;

    // -------------------------- Static bbox rebind -------------------------
    struct StaticRebind {
        // Автоматическая перепривязка static bbox при потере родительской dynamic цели.
        bool auto_rebind = true;

        // Таймаут (мс) ожидания новой цели после потери родительского bbox.
        int rebind_timeout_ms = 1200;

        // Приоритет расстояния (distance priority).
        float distance_weight = 1.0f;

        // Приоритет размера цели (area priority).
        float area_weight = 1.0f;

        // Во сколько раз новая цель должна быть крупнее предыдущей,
        // чтобы считаться значимо более крупной.
        float larger_area_factor = 2.0f;

        // Ограничение: не брать слишком далёкую крупную цель.
        // Это доля диагонали кадра: 0.2 = 1/5 диагонали.
        float max_large_target_dist_frac = 0.2f;

        // Порог IoU для "прилипшего" static bbox к родительской цели
        // (используется при проверке, что static ещё привязан к нужной dynamic цели).
        float parent_iou_th = 0.15f;

        // Порог уверенности (скор) для повторной "реаттач" привязки.
        // Нужен, чтобы не дёргаться на шумных/сомнительных совпадениях.
        float reattach_score_th = 0.20f;
    } static_rebind;

    // ------------------------------- Overlay -------------------------------
    struct Overlay {
        // Прозрачность HUD (Heads-Up Display).
        float hud_alpha = 0.25f;

        // Прозрачность невыбранных bbox, когда есть активный static bbox.
        float unselected_alpha_when_selected = 0.3f;
    } overlay;

    // ------------------------------ Smoothing ------------------------------
    struct Smoothing {
        // Окно сглаживания (moving average) для динамических bbox.
        // Если код сглаживания отключён — параметр пока не влияет.
        int dynamic_bbox_window = 5;
    } smoothing;
};

// Загрузка конфигурации из TOML.
// Возвращает true, если файл прочитан и распарсен успешно.
// Если файл отсутствует или содержит ошибки — возвращает false, но дефолты остаются.
bool load_config(const std::string& path, AppConfig& cfg);
